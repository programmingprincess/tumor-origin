mirNames = rbind.fill(mirNames, temp_dataset)
rm(temp_dataset)
}
}
dim(mirNames)
for (file in mergeFiles){
if(!exists("mirNames")){
mirNames = read.table(file, header=TRUE, stringsAsFactors=FALSE)
dim(mirNames)
}
if(exists("mirNames")){
temp_dataset = read.table(file, header=TRUE, stringsAsFactors=FALSE)
mirNames = rbind.fill(mirNames, temp_dataset)
rm(temp_dataset)
}
}
for (file in mergeFiles){
if(!exists("mirNames")){
mirNames = read.table(file, header=TRUE, stringsAsFactors=FALSE)
dim(mirNames)
}
if(exists("mirNames")){
temp_dataset = read.table(file, header=TRUE, stringsAsFactors=FALSE)
mirNames = rbind.fill(mirNames, temp_dataset)
dim(mirNames)
rm(temp_dataset)
}
}
for (file in mergeFiles){
if(!exists("mirNames")){
mirNames = read.table(file, header=TRUE, stringsAsFactors=FALSE)
dim(mirNames)
}
if(exists("mirNames")){
temp_dataset = read.table(file, header=TRUE, stringsAsFactors=FALSE)
mirNames = rbind.fill(mirNames, temp_dataset)
print("haha!!!!")
rm(temp_dataset)
} else {
print("oh no")
}
}
#INPUT: 1) Lookup table of mature miR names and accession #s (hsa_miR_accessionTOname.txt)
#       2) a directpry of individual miRNA "isofom" level TCGA data matrices downloaded using TCGA-Assembler... i.e:
#################################################################################
#OUTPUT: an udpated data matrix with full miRNA names.
#################################################################################
#change directory to a directory containing files to update and accessionTOname file i.e.: > setwd("Desktop/miRdata/")
library(splitstackshape)
library(qdap)
library(plyr)
library(reshape)
filenames = dir(pattern="*isoform.quantification.txt")
update_miRname = function(infile)
{
tempFile = read.table(infile, header=TRUE, stringsAsFactors=FALSE)
tempFile =cSplit(tempFile, "miRNA_region", sep=",")
full_list = read.table("hsa_miR_accessionTOname.txt", header=TRUE, stringsAsFactors=FALSE)
tempFile$fullName = lookup(tempFile$miRNA_region_2, full_list$Alias, full_list$Name)
temp2 = data.frame(tempFile$fullName, tempFile$read_count)
colnames(temp2) = c("miRNA", "Count")
write.table(tempFile, file=paste(infile, ".names.txt", sep=""),sep="\t",col.names=TRUE, row.names=FALSE)
write.table(temp2, file=paste(infile, ".counts.txt", sep=""),sep="\t",col.names=TRUE, row.names=FALSE)
temp3 = temp2[!(is.na(temp2[,1])),]
temp3 = temp3[order(temp3[,1]), ]
temp3 = aggregate(data=temp3, temp3[,2] ~ temp3[,1], FUN=sum)
colnames(temp3) = c("miRNA", infile)
write.table(temp3, file=paste(infile, ".sumSort.txt", sep=""),sep="\t",col.names=TRUE, row.names=FALSE)
}
lapply(filenames, update_miRname)
#next need to join all the data matrix files into one matrix
mergeFiles = list.files(pattern="*sumSort.txt")
mirNames = data.table(NULL)
for (file in mergeFiles){
if(!exists("mirNames")){
mirNames = read.table(file, header=TRUE, stringsAsFactors=FALSE)
dim(mirNames)
}
if(exists("mirNames")){
temp_dataset = read.table(file, header=TRUE, stringsAsFactors=FALSE)
mirNames = rbind.fill(mirNames, temp_dataset)
print("haha!!!!")
rm(temp_dataset)
} else {
print("oh no")
}
}
mirNames = as.matrix(mirNames[,1])
mirNames = as.data.frame((sort(unique(mirNames))))
colnames(mirNames) = "miRNA"
# merge each file with this generated names column, putting zero if no match
import.list <- llply(mergeFiles, read.table, header=TRUE)
data_matrix =join(mirNames, as.data.frame(import.list[1]), by= "miRNA", type="left")
for(i in 2:length(mergeFiles)){
data_matrix =join(data_matrix, as.data.frame(import.list[i]), by= "miRNA", type="left")
}
data_matrix[is.na(data_matrix)] = 0
write.table(data_matrix, file="miR_counts_matrix.txt", sep="\t", col.names=TRUE, row.names=FALSE)
mirNames
#INPUT: 1) Lookup table of mature miR names and accession #s (hsa_miR_accessionTOname.txt)
#       2) a directpry of individual miRNA "isofom" level TCGA data matrices downloaded using TCGA-Assembler... i.e:
#################################################################################
#OUTPUT: an udpated data matrix with full miRNA names.
#################################################################################
#change directory to a directory containing files to update and accessionTOname file i.e.: > setwd("Desktop/miRdata/")
library(splitstackshape)
library(qdap)
library(plyr)
library(reshape)
filenames = dir(pattern="*isoform.quantification.txt")
update_miRname = function(infile)
{
tempFile = read.table(infile, header=TRUE, stringsAsFactors=FALSE)
tempFile =cSplit(tempFile, "miRNA_region", sep=",")
full_list = read.table("hsa_miR_accessionTOname.txt", header=TRUE, stringsAsFactors=FALSE)
tempFile$fullName = lookup(tempFile$miRNA_region_2, full_list$Alias, full_list$Name)
temp2 = data.frame(tempFile$fullName, tempFile$read_count)
colnames(temp2) = c("miRNA", "Count")
write.table(tempFile, file=paste(infile, ".names.txt", sep=""),sep="\t",col.names=TRUE, row.names=FALSE)
write.table(temp2, file=paste(infile, ".counts.txt", sep=""),sep="\t",col.names=TRUE, row.names=FALSE)
temp3 = temp2[!(is.na(temp2[,1])),]
temp3 = temp3[order(temp3[,1]), ]
temp3 = aggregate(data=temp3, temp3[,2] ~ temp3[,1], FUN=sum)
colnames(temp3) = c("miRNA", infile)
write.table(temp3, file=paste(infile, ".sumSort.txt", sep=""),sep="\t",col.names=TRUE, row.names=FALSE)
}
lapply(filenames, update_miRname)
#next need to join all the data matrix files into one matrix
mergeFiles = list.files(pattern="*sumSort.txt")
mirNames = data.table(NULL)
for (file in mergeFiles){
if(!exists("mirNames")){
mirNames = read.table(file, header=TRUE, stringsAsFactors=FALSE)
dim(mirNames)
}
if(exists("mirNames")){
temp_dataset = read.table(file, header=TRUE, stringsAsFactors=FALSE)
mirNames = rbind.fill(mirNames, temp_dataset)
print("haha!!!!")
rm(temp_dataset)
} else {
print("oh no")
}
}
mirNames = as.matrix(mirNames[,1])
mirNames = as.data.frame((sort(unique(mirNames))))
colnames(mirNames) = "miRNA"
# merge each file with this generated names column, putting zero if no match
import.list <- llply(mergeFiles, read.table, header=TRUE)
data_matrix =join(mirNames, as.data.frame(import.list[1]), by= "miRNA", type="left")
for(i in 2:length(mergeFiles)){
data_matrix =join(data_matrix, as.data.frame(import.list[i]), by= "miRNA", type="left")
}
data_matrix[is.na(data_matrix)] = 0
write.table(data_matrix, file="miR_counts_matrix.txt", sep="\t", col.names=TRUE, row.names=FALSE)
unloadNamespace('data.table')
unloadNamespace('reshape2')
unloadNamespace('plyr')
install.packages("data.table", type="source", dependencies=TRUE)
#INPUT: 1) Lookup table of mature miR names and accession #s (hsa_miR_accessionTOname.txt)
#       2) a directpry of individual miRNA "isofom" level TCGA data matrices downloaded using TCGA-Assembler... i.e:
#################################################################################
#OUTPUT: an udpated data matrix with full miRNA names.
#################################################################################
#change directory to a directory containing files to update and accessionTOname file i.e.: > setwd("Desktop/miRdata/")
library(splitstackshape)
library(qdap)
library(plyr)
library(reshape)
filenames = dir(pattern="*isoform.quantification.txt")
update_miRname = function(infile)
{
tempFile = read.table(infile, header=TRUE, stringsAsFactors=FALSE)
tempFile =cSplit(tempFile, "miRNA_region", sep=",")
full_list = read.table("hsa_miR_accessionTOname.txt", header=TRUE, stringsAsFactors=FALSE)
tempFile$fullName = lookup(tempFile$miRNA_region_2, full_list$Alias, full_list$Name)
temp2 = data.frame(tempFile$fullName, tempFile$read_count)
colnames(temp2) = c("miRNA", "Count")
write.table(tempFile, file=paste(infile, ".names.txt", sep=""),sep="\t",col.names=TRUE, row.names=FALSE)
write.table(temp2, file=paste(infile, ".counts.txt", sep=""),sep="\t",col.names=TRUE, row.names=FALSE)
temp3 = temp2[!(is.na(temp2[,1])),]
temp3 = temp3[order(temp3[,1]), ]
temp3 = aggregate(data=temp3, temp3[,2] ~ temp3[,1], FUN=sum)
colnames(temp3) = c("miRNA", infile)
write.table(temp3, file=paste(infile, ".sumSort.txt", sep=""),sep="\t",col.names=TRUE, row.names=FALSE)
}
lapply(filenames, update_miRname)
#next need to join all the data matrix files into one matrix
mergeFiles = list.files(pattern="*sumSort.txt")
mirNames = data.table(NULL)
for (file in mergeFiles){
if(!exists("mirNames")){
mirNames = read.table(file, header=TRUE, stringsAsFactors=FALSE)
dim(mirNames)
}
if(exists("mirNames")){
temp_dataset = read.table(file, header=TRUE, stringsAsFactors=FALSE)
mirNames = rbind.fill(mirNames, temp_dataset)
print("haha!!!!")
rm(temp_dataset)
} else {
print("oh no")
}
}
mirNames = as.matrix(mirNames[,1])
mirNames = as.data.frame((sort(unique(mirNames))))
colnames(mirNames) = "miRNA"
# merge each file with this generated names column, putting zero if no match
import.list <- llply(mergeFiles, read.table, header=TRUE)
data_matrix =join(mirNames, as.data.frame(import.list[1]), by= "miRNA", type="left")
for(i in 2:length(mergeFiles)){
data_matrix =join(data_matrix, as.data.frame(import.list[i]), by= "miRNA", type="left")
}
data_matrix[is.na(data_matrix)] = 0
write.table(data_matrix, file="miR_counts_matrix.txt", sep="\t", col.names=TRUE, row.names=FALSE)
install.packages("data.table")
library(randomForest)
rfmodel <- randomForest(type ~ ., data=blca_train, importance=TRUE, do.trace=100)
blca <- subset(t_data, type=="blca")
not_blca <- t_data[sample(which(t_data$type != "blca"), nrow(t_blca)), ]
## count cancers in random sample
# nrow(subset(not_blca,type=="chol"))
## p l o t distribution for not sample
# qplot(not_blca$type)
t_blca <- rbind(blca, not_blca)
n = nrow(t_blca)
set.seed(30)
ntrain = floor(n*0.60)  # 70% train
ii=sample(1:n, ntrain)
blca_train = t_blca[ii,]
blca_test = t_blca[-ii,]
setwd("~/Desktop/tumor-origin")
############################################################
## Part 2
## Following "raw_data_working.R"
## Already transposed
############################################################
#TODO: library(pROC)...why are $y and $votes not the same length? what do they mean
#TODO: undersampling
#TODO: nnnet with 17 samples
#TODO: feature selection...
t_data = read.table("raw_table_labeled.txt", header=TRUE, stringsAsFactors=FALSE)
t_data = as.data.frame(t_data)
t_data$type <- as.factor(t_data$type)
#t_data[is.na(t_data)] <- 0
bar <- subset(foo, location == "there")
########################
blca <- subset(t_data, type=="blca")
not_blca <- t_data[sample(which(t_data$type != "blca"), nrow(t_blca)), ]
## count cancers in random sample
# nrow(subset(not_blca,type=="chol"))
## p l o t distribution for not sample
# qplot(not_blca$type)
t_blca <- rbind(blca, not_blca)
n = nrow(t_blca)
set.seed(30)
ntrain = floor(n*0.60)  # 70% train
ii=sample(1:n, ntrain)
blca_train = t_blca[ii,]
blca_test = t_blca[-ii,]
library(randomForest)
rfmodel <- randomForest(type ~ ., data=blca_train, importance=TRUE, do.trace=100)
dim(t_data$type)
dim(t_data)
dim(t_data$type)
t_data$type
t_data$type <- as.factor(t_data$type)
blca <- subset(t_data, type=="blca")
not_blca <- t_data[sample(which(t_data$type != "blca"), nrow(t_blca)), ]
## count cancers in random sample
# nrow(subset(not_blca,type=="chol"))
## p l o t distribution for not sample
# qplot(not_blca$type)
t_blca <- rbind(blca, not_blca)
n = nrow(t_blca)
set.seed(30)
ntrain = floor(n*0.60)  # 70% train
ii=sample(1:n, ntrain)
blca_train = t_blca[ii,]
blca_test = t_blca[-ii,]
library(randomForest)
rfmodel <- randomForest(type ~ ., data=blca_train, importance=TRUE, do.trace=100)
t_blca <- rbind(blca, not_blca)
not_blca <- t_data[sample(which(t_data$type != "blca"), nrow(t_blca)), ]
blca <- subset(t_data, type=="blca")
not_blca <- t_data[sample(which(t_data$type != "blca"), nrow(t_blca)), ]
blca <- subset(t_data, type=="blca")
not_blca <- t_data[sample(which(t_data$type != "blca"), nrow(blca)), ]
## count cancers in random sample
# nrow(subset(not_blca,type=="chol"))
## p l o t distribution for not sample
# qplot(not_blca$type)
t_blca <- rbind(blca, not_blca)
n = nrow(t_blca)
set.seed(30)
ntrain = floor(n*0.60)  # 70% train
ii=sample(1:n, ntrain)
blca_train = t_blca[ii,]
blca_test = t_blca[-ii,]
library(randomForest)
rfmodel <- randomForest(type ~ ., data=blca_train, importance=TRUE, do.trace=100)
rfmodel
rfpred <- predict(rfmodel, newdata=blca_test,type="prob")
table(rfpred,blca_test$type)
blca_train = t_blca[ii,]
blca_test = t_blca[-ii,]
table(rfpred, blca_test$type)
rfpred <- predict(rfmodel, newdata=blca_test,type="prob")
table(rfpred, blca_test$type)
rfpred
rfpred <- predict(rfmodel, newdata=blca_test)
table(rfpred, blca_test$type)
rfpred <- predict(rfmodel, blca_test, type="prob")
rfpred
rfroc <- roc(blca_test$type, rfpred$versicolor) # Draw ROC curve.
source('~/Desktop/tumor-origin/tang_rf_2.r', echo=TRUE)
library(pROC)
rfroc <- roc(blca_test$type, rfpred$versicolor) # Draw ROC curve.
dim(rfpred)
rfpred <- predict(rfmodel, newdata=blca_test, type="prob")
rfpred <- predict(rfmodel, newdata=blca_test)
rfpred <- predict(rfmodel, newdata=blca_test)
rfpred <- predict(rfmodel, newdata=blca_test)
library(pROC)
rfroc <- roc(blca_test$type, rfpred$versicolor) # Draw ROC curve.
plot(result.roc, print.thres="best", print.thres.best.method="closest.topleft")
rfpred <- predict(rfmodel, newdata=blca_test, type = "prob")
rfpred
rfroc <- roc(blca_test$type, rfpred$versicolor) # Draw ROC curve.
rfmodel$votes
rfmodel$votes[,2]
rfroc <- roc(blca_test$type, rfmodel$votes[,2])
rfmodel$votes[,3]
rfmodel$votes[,5]
rfmodel$votes[2,]
rfmodel$votes[2,2]
rfmodel$votes[,2]
rfroc <- roc(blca_test$type, rfpred$versicolor) # Draw ROC curve.
rfroc <- roc(blca_test$type, rfmodel$votes[,2])
rfroc <- roc(blca_train$type, rfmodel$votes[,2])
plot(rfroc)
auc(rfroc)
plot(rfroc)
auc(rfroc)
rfmodel
rfpred = as.factor(rfpred)
rfpred <- as.factor(rfpred)
rfpred
rfpred <- predict(rfmodel, newdata=blca_test, type = "prob")
rfpred[,2]
# plot(rfroc, print.thres="best", print.thres.best.method="closest.topleft")
rfroc <- roc(blca_train$type, rfpred[,2])
rfroc <- roc(blca_test$type, rfpred[,2])
plot(rfroc)
auc(rfroc)
rfroc <- roc(blca_test$type, rfpred[,2]) # Draw ROC curve.
plot(rfroc, print.thres="best", print.thres.best.method="closest.topleft")
auc(rfroc)
setwd("~/Desktop/tumor-origin")
############################################################
## Part 2
## Following "raw_data_working.R"
## Already transposed
############################################################
#TODO: library(pROC)...why are $y and $votes not the same length? what do they mean
#TODO: undersampling
#TODO: nnnet with 17 samples
#TODO: feature selection...
t_data = read.table("raw_table_labeled.txt", header=TRUE, stringsAsFactors=FALSE)
t_data = as.data.frame(t_data)
t_data$type <- as.factor(t_data$type)
#t_data[is.na(t_data)] <- 0
########################
#
# blca <- subset(t_data, type=="blca")
# not_blca <- t_data[sample(which(t_data$type != "blca"), nrow(blca)), ]
# ## count cancers in random sample
# # nrow(subset(not_blca,type=="chol"))
# ## p l o t distribution for not sample
# # qplot(not_blca$type)
# t_blca <- rbind(blca, not_blca)
#
# n = nrow(t_blca)
# set.seed(30)
# ntrain = floor(n*0.60)  # 70% train
# ii=sample(1:n, ntrain)
#
# blca_train = t_blca[ii,]
# blca_test = t_blca[-ii,]
#
# library(randomForest)
# rfmodel <- randomForest(type ~ ., data=blca_train, importance=TRUE, do.trace=100)
# rfpred <- predict(rfmodel, newdata=blca_test)
# # table(rfpred, blca_test$type)
#
#
# rfpred <- predict(rfmodel, newdata=blca_test, type = "prob")
# library(pROC)
# rfroc <- roc(blca_test$type, rfpred[,2]) # Draw ROC curve.
# plot(rfroc, print.thres="best", print.thres.best.method="closest.topleft")
# auc(rfroc)
#
# # rfroc <- roc(blca_test$type, rfpred[,2])
# # plot(rfroc)
# # auc(rfroc)
####################################################
## Model Training
####################################################
# split into train and test
n = nrow(t_data)
set.seed(30)
ntrain = floor(n*0.50)  # 70% train
ii=sample(1:n, ntrain)
data_train = t_data[ii,]
data_test = t_data[-ii,]
library(randomForest)
rfmodel <- randomForest(type ~ ., data=data_train, importance=TRUE, do.trace=100)
#> (199+644+20+230+60+259+39+314+206+256+262+72+286+198+216+284+255)/nrow(data_train)
#[1] 0.9559748
# save(rfmodel, file="rfmodel_raw_11152018.RData")
# capture.output(rfmodel, file="rfModel_raw_11152018.txt")
#
#> (216+516+17+223+54+294+41+291+214+259+224+82+261+250+233+285+276)/nrow(data_test)
#[1] 0.9398742
# rn <- round(importance(rfmodel), 2)
# rn
#head(rn[order(rn[,6],decreasing=TRUE),],10)
rfpred <- predict(rfmodel, newdata=data_test)
table(rfpred,data_test$type)
library(pROC)
rfroc <- roc(data_test$type, rfpred[,2]) # Draw ROC curve.
plot(rfroc, print.thres="best", print.thres.best.method="closest.topleft")
auc(rfroc)
rfpred <- predict(rfmodel, newdata=data_test, type="prob")
table(rfpred,data_test$type)
library(pROC)
rfroc <- roc(data_test$type, rfpred[,2]) # Draw ROC curve.
plot(rfroc, print.thres="best", print.thres.best.method="closest.topleft")
auc(rfroc)
rfmodel
plot(cars)
t_data <- read.table("raw_table_labeled.txt", header=TRUE, stringsAsFactors=FALSE)
t_data <- as.data.frame(t_data)
t_data$type <- as.factor(t_data$type)
dim(t_data)
library(randomForest)
```{r}
# split into train and test
n = nrow(t_data)
set.seed(30)
ntrain = floor(n*0.50)  # 70% train
ii=sample(1:n, ntrain)
data_train = t_data[ii,]
data_test = t_data[-ii,]
library(randomForest)
rfmodel <- randomForest(type ~ ., data=data_train, importance=TRUE, do.trace=100)
rfmodel
nnmodel = nnet(type ~ ., data_train,size=5,decay=.1,maxit=1000)
library(nnet)
nnmodel = nnet(type ~ ., data_train,size=5,decay=.1,maxit=1000)
nnmodel = nnet(type ~ ., data_train,size=5,decay=.1,maxit=100,MaxNWts=12122)
nnyhat = predict(nnmodel, data_test,type="prob")
nnyhat = predict(nnmodel, data_test,type="raw")
nnroc <- roc(data_test$type, nnyhat[,2]) # Draw ROC curve.
plot(nnroc, print.thres="best", print.thres.best.method="closest.topleft")
auc(nnroc)
nnmodel = nnet(type ~ ., data_train,size=5,decay=.1,maxit=1000,MaxNWts=12122)
nnyhat = predict(nnmodel, data_test,type="raw")
nnroc <- roc(data_test$type, nnyhat[,2]) # Draw ROC curve.
plot(nnroc, print.thres="best", print.thres.best.method="closest.topleft")
auc(nnroc)
nnraw = predict(nnmodel, data_test,type="raw")
nnroc <- roc(data_test$type, nnraw[,2]) # Draw ROC curve.
plot(nnraw, print.thres="best", print.thres.best.method="closest.topleft")
auc(nnraw)
plot(nnroc, print.thres="best", print.thres.best.method="closest.topleft")
auc(nnraw)
nnroc <- roc(data_test$type, nnraw[,2]) # Draw ROC curve.
plot(nnroc, print.thres="best", print.thres.best.method="closest.topleft")
auc(nnraw)
nnraw = predict(nnmodel, data_test,type="raw")
nnroc <- roc(data_test$type, nnraw[,2]) # Draw ROC curve.
plot(nnroc, print.thres="best", print.thres.best.method="closest.topleft")
auc(nnroc)
nnclass = predict(nnmodel, data_test,type="class")
table(nnclass,data_test$type)
table(nnclass,data_test$type)
nnmodel
table(nnclass,data_test$type)
nnmodel
nnmodel$fitted.values
nnmodel$xlevels
nnmodel$coefnames
plot(nnroc, print.thres="best", print.thres.best.method="closest.topleft",print.auc = TRUE,col="blue")
multiclass.roc(nnroc, data_test$type, nnraw[,2])
multiclass.roc( data_test$type, nnraw[,2])
lolroc <- multiclass.roc( data_test$type, nnraw[,2])
lolroc
plot(lolroc)
auc(lolroc)
lolroc <- multiclass.roc( data_test$type, as.numeric(nnraw))
lolroc <- multiclass.roc( data_test$type, as.numeric(nnraw[,2]))
rs <- lolroc[['rocs']]
plot.roc(rs[[1]])
rs <- lolroc[['rocs']]
plot.roc(rs[[1]])
rs
sapply(2:length(rs),function(i) lines.roc(rs[[i]],col=i))
lolroc$rocs
lolroc$percent
lolroc$auc
lolroc$predictor
